// You are given an array of non-overlapping
// intervals intervals where 
// intervals[i] = [starti, endi] represent 
// the start and the end of the ith interval
// and intervals is sorted in ascending order
// by starti. You are also given an
// interval newInterval = [start, end] that 
// represents the start and end of another
// interval.
// Insert newInterval into intervals such
// that intervals is still sorted in 
// ascending order by starti and intervals
// still does not have any overlapping intervals
// (merge overlapping intervals if necessary).
// Return intervals after the insertion.

// Note that you don't need to modify 
// intervals in-place. You can make a 
// new array and return it.

// - 0 <= intervals.length <= 10^4
// - intervals[i].length == 2
// - 0 <= starti <= endi <= 10^5
// - intervals is sorted by starti in ascending order
// - newInterval.length == 2
// - 0 <= start <= end <= 10^5
class Solution {
    public int[][] insert(int[][] intervals, int[] newInterval) {
        int n=intervals.length;
        int[][] array=new int[n+1][2];
        int k=0;
        for(int[] e:intervals){
            array[k++]=e;
        }
        array[n]=newInterval;
        Arrays.sort(array,(a,b)->a[0]-b[0]);

        List<int[]> merge=new ArrayList<>();
        merge.add(array[0]);

        for(int i=1;i<n+1;i++){
            int[] cur=array[i];
            int[] pre=merge.get(merge.size()-1);

            if(pre[1]>=cur[0]){
               pre[1]=Math.max(pre[1],cur[1]);
            }
            else{
               merge.add(array[i]); 
            }
        }

        int[][] ret=new int[merge.size()][2];
        for(int i=0;i<merge.size();i++){
            ret[i]=merge.get(i);
        }

        return ret;


    }
}

// Time	O(n log n)
// Space	O(n)